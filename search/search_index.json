{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cloud Workstations","text":"<p>Cloud Workstations are remote development machines hosted in Google cloud. Workstations provide a full-featured development experience and allow users to connect a remote machine to VSCode. Workstations provide a development experience similar to your laptop with some key differences. </p> <p>Workstations\u2026 </p> <ul> <li>run inside your VPC or cloud network so you can access internal sources  </li> <li>are ephemeral and shut down after a maximum runtime</li> <li>run a linux OS and allow you to attach accelerators or change the machine type</li> <li>provide preconfigured environments freeing users from having to worry about their local setup</li> </ul>"},{"location":"#more-details","title":"More details:","text":""},{"location":"#authentication","title":"Authentication","text":"<ul> <li>Users authenticate to a workstation via IAM using their LDAP. This means that running <code>gcloud auth login</code>, etc. is necessary to access google services from the workstation. Like on your laptop, this cached credential is valid for 12 hours and persists between workstation sessions.</li> <li>Compared to VertexAI notebooks and CustomJobs, which are typically run as a service account, workstation sessions have more narrowly scoped access. By default, only the creator of a workstation has access to that workstation instance.</li> </ul>"},{"location":"#configuration","title":"Configuration","text":"<ul> <li>Like your laptop, workstations will go to sleep/shutdown after a period of inactivity. Additionally, there is a maximum runtime before it is shut off. These values are set in the workstation definition (config), and we have started with some defaults.  This activity is measured via SSH or HTTP traffic.    Furthermore, anything in <code>/home/</code> will persist between sessions.</li> </ul>"},{"location":"#ide","title":"IDE","text":"<ul> <li>There are two ways to use the IDE:<ul> <li>via the web browser, which does not requires an SSH connection, ensuring low latency </li> <li>by attaching your IDE remote workstation via the remote SSH extension</li> </ul> </li> <li>Google has some examples of the open source VSCode and Jetbrains.</li> </ul>"},{"location":"#setup","title":"Setup","text":"<p>Install the workstation CLI using pip or (recommended) pipx</p> <pre><code>pipx install cloud-workstation\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#determine-the-type-of-workstation-you-want-to-create","title":"Determine the type of workstation you want to create","text":"<p>Using the command <code>workstation list-configs</code> you can see all configs that are available to you. New workstation configs can be added by an admin. If you have questions about which config to use or have a use case for a new config, please reach out ot #machine-learning-tools.</p> <p><pre><code>workstation list-configs\n</code></pre> For example you might get a result like this: <pre><code>\u251c\u2500\u2500 Config: medium\n\u2502   \u251c\u2500\u2500 \ud83d\udcbd Image: us-central1-docker.pkg.dev/cloud-workstations-images/predefined/code-oss:latest\n\u2502   \u251c\u2500\u2500 \ud83d\udcbb Machine Type: n2-standard-16\n\u2502   \u251c\u2500\u2500 \u23f3 Idle Timeout (hours): 2.0\n\u2502   \u2514\u2500\u2500 \u23f3 Max Runtime (hours): 12.0\n</code></pre></p> <p>Which indicates that you have the config <code>medium</code> available, and that this will give you a <code>n2-standard-16</code> machine with a 2 hour idle timeout and a 12 hour max runtime.</p>"},{"location":"#create-your-workstation-and-start-it","title":"Create your workstation and start it","text":"<p><pre><code>\u276f workstation create --config medium --name &lt;WORKSTATION NAME&gt;\n\u276f workstation start --name &lt;WORKSTATION NAME&gt;\n</code></pre> If you make a VSCode based IDE image you can also use the <code>--browser</code> option will open VSCode directly in your browser. If you\u2019d like to connect your remote machine to your Desktop VSCode app follow the setup directions for local VS Code and then start your workstation with the <code>--code</code> option.</p> <pre><code>\u276f workstation start --name &lt;WORKSTATION NAME&gt; --code\n</code></pre> <p>You can also ssh directly to your remote machine. For example, running commands like <code>ssh &lt;WORKSTATION NAME&gt;</code> in a local terminal will open an SSH connection to your remote machine.</p> <p>You can use either the <code>workstation</code> CLI or the browser to list, start, and stop workstations. You can view active workstations in the browser at https://console.cloud.google.com/workstations/</p> <p></p>"},{"location":"#connect-to-a-workstation-with-local-vs-code","title":"Connect to a Workstation with local VS Code","text":"<ol> <li>To enable local VS Code to connect to a Workstation, you will need to install the Remote - SSH extension.</li> <li>Setup your <code>~/.ssh/config</code> file to include the following:     <pre><code>Include ~/.workstations/configs/*.config\n</code></pre></li> <li>Once installed, you can connect to a Workstation by clicking on the green icon in the bottom left corner of VS Code and selecting \u201cRemote-SSH: Connect to Host\u2026\u201d. You can then select the workstation host from the list.  </li> <li>Install your extensions on the remote host.  VS Code doesn\u2019t install some like copilot or Python by default on the remote host. But click on the cloud icon and select which extensions you want to install. </li> </ol>"},{"location":"#list-your-workstations","title":"List your workstations","text":"<p>You can go to https://console.cloud.google.com/workstations/ to see you workstations and status or use the <code>workstation list ---user &lt;USER&gt;</code> command</p> <pre><code>\u276f workstation list --user damien\nWorkstations\n\u251c\u2500\u2500 Workstation: damien-medium\n    \u251c\u2500\u2500 \ud83d\uded1 Stopped\n    \u251c\u2500\u2500 User: damien\n    \u251c\u2500\u2500 \ud83d\udcbd Image: us-central1-docker.pkg.dev/cloud-workstations-images/predefined/code-oss:latest\n    \u251c\u2500\u2500 \ud83d\udcbb Machine Type: n2-standard-16\n    \u251c\u2500\u2500 \u23f3 Idle Timeout (hours): 2.0\n    \u2514\u2500\u2500 \u23f3 Max Runtime (hours): 12.0\nTotal Workstations:  1\n</code></pre> <p>Json output is also supported with the <code>--json</code> flag. <pre><code>\u276f workstation list --json | jq '.[] | select(.user == \"damien\" and .state == \"STATE_STOPPED\")'\n</code></pre> Which give you the output: <pre><code>{\n  \"name\": \"damien-medium\",\n  \"user\": \"damien\",\n  \"project\": \"example\",\n  \"location\": \"us-central1\",\n  \"config\": \"vscode-medium\",\n  \"cluster\": \"example\",\n  \"state\": \"STATE_STOPPED\",\n  \"idle_timeout\": 2.0,\n  \"max_runtime\": 12.0,\n  \"type\": \"n2-standard-16\",\n  \"image\": \"us-central1-docker.pkg.dev/cloud-workstations-images/predefined/code-oss:latest\"\n}\n</code></pre></p>"},{"location":"#idle-vs-max-runtime","title":"Idle vs Max Runtime","text":"<p>Idle Timeout is the amount of time the workstation will wait before shutting down if there is no activity based on the config (in the previous config example that is 4 hours). This is measured via SSH or HTTP traffic.  Max Runtime is the maximum amount of time the workstation will run before shutting down regardless of activity. It is possible to create configs that never idle, or have a max runtime.</p>"},{"location":"#syncing-files-to-the-workstation","title":"Syncing files to the workstation","text":"<p>There are a few ways to sync files to the workstation.  A built in way is to use the <code>workstation sync</code> command.  This command will sync the files in <code>~/remote-machines/workstation/</code> to the workstation.  This is useful for syncing your keys and other files that you might like for a customized experience like a custom ~/.zshrc. However there are drag and drop methods, or just doing it directly from the terminal with ssh or rsync.</p> <ol> <li>Option 1: Use <code>workstation sync --name &lt;WORKSTATION_NAME&gt;</code> to sync the keys and anything else in  <code>`~/remote-machines/workstation/</code> to your home directory on the workstation, with additional options for different directories.</li> <li>Option 2: Turn on the workstation and drag and drop the files into the file explorer in VS Code.</li> <li> <p>Option 3: User scp or rsync if you setup your ~/.ssh/config as above and use the commands like normal. For example:</p> <pre><code>rsync -avz --exclude=\".*\" --exclude \"*/__pycache__\" /path/to/local/folder &lt;WORKSTATION&gt;:/path/to/remote/folder\n</code></pre> </li> </ol>"},{"location":"#example-of-using-workstation-sync-to-sync-credentials","title":"Example of using workstation sync to sync credentials","text":"<p>You can sync files from your laptop to the workstation using the <code>workstation sync</code> command.  This command will sync the files in your local <code>~/remote-machines/workstation/</code> directory to the workstation.  This is useful for syncing your keys and other files that you might like for a customized experience like a custom ~/.zshrc. However there are drag and drop methods, or just doing it directly from the terminal. </p> <p>For example, if you have followed the directions on Accessing GitHub and saved the Github certificate in <code>~/remote-machines/workstation/</code> the following command will sync that cert to the remote machine and enable github access.  Syncing credentails or configuration files only needs to happen once after creating the workstation instance since these will persist on the disk. </p> <pre><code>\u276f workstation sync --name damien-medium\nbuilding file list ... done\n./\n.p10k.zsh\n.zsh_plugins.txt\n.zshrc\n.ssh/\n.ssh/id_ed25519\n.ssh/id_ed25519.pub\ntest/\n\nsent 95505 bytes  received 182 bytes  63791.33 bytes/sec\ntotal size is 94956  speedup is 0.99\n</code></pre>"},{"location":"#report-issues","title":"Report issues","text":"<p>Use the issue link above to take you to the repo issue page. Please include the version of the CLI you are using <code>\u276f workstation --version</code> and which config.</p>"},{"location":"#development-and-testing","title":"Development and Testing","text":"<p>We use Hermit to manage the development environment.  To get started, install Hermit and run the following command</p> <pre><code>curl -fsSL https://github.com/cashapp/hermit/releases/download/stable/install.sh | /bin/bash\n</code></pre> <p>After cloning the repo do <code>. bin/activate-hermit</code> which will make the environment available with UV, Ruff, and Just. </p>"},{"location":"#render-docs","title":"Render Docs","text":"<p><code>just docs</code></p>"},{"location":"#run-tests","title":"Run Tests","text":"<p><code>just tests</code></p>"},{"location":"#run-local-copy","title":"Run local copy","text":"<p><code>uv run workstation --version</code></p>"},{"location":"#using-vscode-debugger","title":"Using VSCode Debugger","text":"<p>If you want to use VS Code debug mode use this profile. <pre><code>        {\n            \"name\": \"Python: Module\",\n            \"type\": \"debugpy\",\n            \"request\": \"launch\",\n            \"module\": \"workstation.cli\",\n            \"console\": \"integratedTerminal\",\n            \"args\": [\"list-configs\", \"--cluster\", \"&lt;YOUR-CLUSTER&gt;\"]\n        }\n</code></pre></p>"},{"location":"api/","title":"API","text":""},{"location":"api/#workstation.cli","title":"<code>cli</code>","text":""},{"location":"api/#workstation.cli.cli","title":"<code>cli(context)</code>","text":"<p>Create and manage Google Cloud Workstation.</p> Source code in <code>src/workstation/cli/__init__.py</code> <pre><code>@group_wrapper(name=\"workstation\")\n@click.version_option(package_name=\"cloud-workstation\")\n@click.pass_context\ndef cli(context: click.Context):\n    \"\"\"Create and manage Google Cloud Workstation.\"\"\"\n</code></pre>"},{"location":"api/#workstation.cli.crud","title":"<code>crud</code>","text":"<p>crud module provides command-line interface (CLI) commands for managing workstations.</p> <p>Include functionalities to create, delete, list, start, and stop workstations, as well as manage workstation configurations.</p> <p>Functions:</p> Name Description <code>get_gcloud_config</code> <p>Retrieve GCP configuration details including project, location, and account.</p> <code>common_options</code> <p>Apply common CLI options to commands.</p> <code>create</code> <p>Create a workstation.</p> <code>list_configs</code> <p>List workstation configurations.</p> <code>list</code> <p>List workstations.</p> <code>start</code> <p>Start workstation and optionally open it either locally with VSCode or through VSCode in a browser.</p> <code>stop</code> <p>Stop workstation.</p> <code>delete</code> <p>Delete workstation.</p> <code>sync</code> <p>Sync files to workstation.</p> <code>logs</code> <p>Open logs for the workstation.</p>"},{"location":"api/#workstation.cli.crud.common_options","title":"<code>common_options(func)</code>","text":"<p>Apply common CLI options to commands.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The function to apply the options to.</p> required <p>Returns:</p> Type Description <code>callable</code> <p>The function with common options applied.</p> Source code in <code>src/workstation/cli/crud.py</code> <pre><code>def common_options(func):  # noqa: D103\n    \"\"\"\n    Apply common CLI options to commands.\n\n    Parameters\n    ----------\n    func : callable\n        The function to apply the options to.\n\n    Returns\n    -------\n    callable\n        The function with common options applied.\n    \"\"\"\n    for option in reversed(_common_options):\n        func = option(func)\n    return func\n</code></pre>"},{"location":"api/#workstation.cli.crud.create","title":"<code>create(context, cluster, config, location, name, project, proxy, no_proxy, envs, **kwargs)</code>","text":"<p>Create a workstation.</p> Source code in <code>src/workstation/cli/crud.py</code> <pre><code>@command()\n@common_options\n@click.option(\n    \"--name\",\n    help=\"Name of the workstation to create.\",\n    type=str,\n    metavar=\"&lt;str&gt;\",\n)\n@click.option(\n    \"--proxy\",\n    help=\"proxy setting.\",\n    type=str,\n    metavar=\"&lt;str&gt;\",\n)\n@click.option(\n    \"--no-proxy\",\n    help=\"No proxy setting.\",\n    type=str,\n    metavar=\"&lt;str&gt;\",\n)\n@click.option(\n    \"--env\",\n    \"-e\",\n    \"envs\",\n    type=(str, str),\n    multiple=True,\n    help=\"Environment variables to set at runtime.\",\n    metavar=\"&lt;key value&gt;\",\n)\n@click.pass_context\ndef create(\n    context: click.Context,\n    cluster: str,\n    config: str,\n    location: Optional[str],\n    name: str,\n    project: Optional[str],\n    proxy: Optional[str],\n    no_proxy: Optional[str],\n    envs: Tuple[Tuple[str, str]],\n    **kwargs,\n):\n    \"\"\"Create a workstation.\"\"\"\n    # Make sure the user is authenticated\n    check_gcloud_auth()\n\n    project, location, account = get_gcloud_config(project=project, location=location)\n\n    # Ensure USER is set on laptop\n    user = getpass.getuser()\n\n    try:\n        from block.mlds.proxy.block import Proxy\n\n        proxies = Proxy(project=project, name=name)\n        proxy = proxies.proxy\n        no_proxy = proxies.no_proxy\n    except ImportError:\n        pass\n\n    if config_manager.check_if_config_exists(name):\n        console.print(f\"Workstation config for {name} already exists.\")\n        overwrite = Confirm.ask(\"Overwrite config?\")\n        if not overwrite:\n            console.print(f\"Exiting without creating workstation {name}.\")\n            sys.exit(0)\n\n    _ = create_workstation(\n        cluster=cluster,\n        config=config,\n        name=name,\n        user=user,\n        account=account,\n        project=project,\n        location=location,\n        proxy=proxy,\n        no_proxy=no_proxy,\n        envs=envs,\n    )\n\n    config_manager.write_ssh_config(\n        name=name,\n        user=user,\n        cluster=cluster,\n        region=location,\n        project=project,\n        config=config,\n    )\n\n    console.print(f\"Workstation {name} created.\")\n</code></pre>"},{"location":"api/#workstation.cli.crud.delete","title":"<code>delete(context, **kwargs)</code>","text":"<p>Delete workstation.</p> Source code in <code>src/workstation/cli/crud.py</code> <pre><code>@command()\n@click.option(\n    \"-n\",\n    \"--name\",\n    help=\"Name of the workstation to delete.\",\n    type=str,\n    metavar=\"&lt;str&gt;\",\n)\n@click.pass_context\ndef delete(context: click.Context, **kwargs):\n    \"\"\"Delete workstation.\"\"\"\n    # Make sure the user is authenticated\n    check_gcloud_auth()\n\n    workstation_details = config_manager.read_configuration(kwargs[\"name\"])\n\n    response = delete_workstation(**workstation_details)\n    config_manager.delete_configuration(kwargs[\"name\"])\n    if response.state.value == 0:\n        console.print(f\"Workstation {kwargs['name']} deleted.\")\n</code></pre>"},{"location":"api/#workstation.cli.crud.get_gcloud_config","title":"<code>get_gcloud_config(project, location)</code>","text":"<p>Retrieve GCP configuration details including project, location, and account.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>GCP project name.</p> required <code>location</code> <code>str</code> <p>GCP location.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing project, location, and account details.</p> Source code in <code>src/workstation/cli/crud.py</code> <pre><code>def get_gcloud_config(project: Optional[str], location: Optional[str]):  # noqa: D103\n    \"\"\"\n    Retrieve GCP configuration details including project, location, and account.\n\n    Parameters\n    ----------\n    project : str, optional\n        GCP project name.\n    location : str, optional\n        GCP location.\n\n    Returns\n    -------\n    tuple\n        A tuple containing project, location, and account details.\n    \"\"\"\n    config_project, config_location, account = read_gcloud_config()\n\n    if project is None:\n        if config_project is not None:\n            project = config_project\n        else:\n            raise ValueError(\n                \"Project not found in gcloud config and was not passed in.\"\n            )\n\n    if location is None:\n        if config_location is not None:\n            location = config_location\n        else:\n            raise ValueError(\n                \"Location not found in gcloud config and was not passed in.\"\n            )\n\n    if account is None:\n        raise ValueError(\"Account not found in gcloud config.\")\n\n    return project, location, account\n</code></pre>"},{"location":"api/#workstation.cli.crud.list","title":"<code>list(context, project, location, all, user, export_json, cluster, **kwargs)</code>","text":"<p>List workstations.</p> Source code in <code>src/workstation/cli/crud.py</code> <pre><code>@command()\n@common_options\n@click.option(\n    \"--json\",\n    \"export_json\",\n    default=False,\n    is_flag=True,\n    help=\"print json output\",\n)\n@click.option(\n    \"-u\",\n    \"--user\",\n    default=getpass.getuser(),\n    help=\"Lists workstations only from a given user.\",\n)\n@click.option(\n    \"-a\", \"--all\", is_flag=True, default=False, help=\"List workstations from all users.\"\n)\n@click.pass_context\ndef list(\n    context: click.Context,\n    project: Optional[str],\n    location: Optional[str],\n    all: bool,\n    user: str,\n    export_json: bool,\n    cluster: str,\n    **kwargs,\n):\n    \"\"\"List workstations.\"\"\"\n    # Make sure the user is authenticated\n    check_gcloud_auth()\n\n    project, location, account = get_gcloud_config(project=project, location=location)\n\n    workstations = list_workstations(\n        cluster=cluster,\n        project=project,\n        location=location,\n    )\n\n    results = []\n    for workstation in workstations:\n        if not all and workstation.get(\"env\", {}).get(\"LDAP\") != user:\n            continue\n\n        result = {\n            \"name\": workstation[\"name\"].split(\"/\")[-1],\n            \"user\": workstation[\"env\"][\"LDAP\"],\n            \"project\": workstation[\"project\"],\n            \"location\": workstation[\"location\"],\n            \"config\": workstation[\"config\"][\"name\"].split(\"/\")[-1],\n            \"cluster\": workstation[\"cluster\"],\n            \"state\": workstation[\"state\"].name,\n            \"idle_timeout\": workstation[\"config\"][\"idle_timeout\"],\n            \"max_runtime\": workstation[\"config\"][\"max_runtime\"],\n            \"type\": workstation[\"config\"][\"machine_type\"],\n            \"image\": workstation[\"config\"][\"image\"],\n        }\n        results.append(result)\n\n    if export_json:\n        json_data = json.dumps(results, indent=4)\n        console.print(json_data)\n    else:\n        tree = Tree(\"Workstations\", style=\"bold blue\")\n\n        for result in results:\n            if result[\"state\"] == \"STATE_RUNNING\":\n                status = \":play_button: Running\"\n            elif result[\"state\"] == \"STATE_STOPPED\":\n                status = \":stop_sign: Stopped\"\n            elif result[\"state\"] == \"STATE_STARTING\":\n                status = \":hourglass: Starting\"\n            elif result[\"state\"] == \"STATE_STOPPING\":\n                status = \":hourglass: Stopping\"\n            else:\n                status = \":question: State unknown\"\n\n            config_branch = tree.add(f\"Workstation: {result['name']}\")\n            config_branch.add(f\"{status}\", style=\"white\")\n            config_branch.add(f\"User: {result['user']}\", style=\"white\")\n            config_branch.add(f\":minidisc: Image: {result['image']}\")\n            config_branch.add(f\":computer: Machine Type: {result['type']}\")\n            config_branch.add(\n                f\":hourglass_flowing_sand: Idle Timeout (s): {str(result['idle_timeout'])}\"\n            )\n            config_branch.add(\n                f\":hourglass_flowing_sand: Max Runtime (s): {str(result['max_runtime'])}\"\n            )\n\n        console.print(tree)\n        console.print(\"Total Workstations: \", len(tree.children))\n</code></pre>"},{"location":"api/#workstation.cli.crud.list_configs","title":"<code>list_configs(context, project, location, cluster, **kwargs)</code>","text":"<p>List workstation configurations.</p> Source code in <code>src/workstation/cli/crud.py</code> <pre><code>@command()\n@common_options\n@click.pass_context\ndef list_configs(\n    context: click.Context,\n    project: Optional[str],\n    location: Optional[str],\n    cluster: str,\n    **kwargs,\n):\n    \"\"\"List workstation configurations.\"\"\"\n    # Make sure the user is authenticated\n    check_gcloud_auth()\n\n    project, location, account = get_gcloud_config(project=project, location=location)\n    configs = list_workstation_configs(\n        cluster=cluster,\n        project=project,\n        location=location,\n    )\n\n    console.print(config_tree(configs))\n</code></pre>"},{"location":"api/#workstation.cli.crud.logs","title":"<code>logs(name, project, **kwargs)</code>","text":"<p>Open logs for the workstation.</p> Source code in <code>src/workstation/cli/crud.py</code> <pre><code>@command()\n@click.argument(\n    \"name\",\n    type=str,\n)\n@click.option(\n    \"--project\",\n    help=\"Name of the workstation GCP project.\",\n    type=str,\n    metavar=\"&lt;str&gt;\",\n)\ndef logs(name: str, project: str, **kwargs):\n    \"\"\"Open logs for the workstation.\"\"\"\n    check_gcloud_auth()\n    instances = get_instance_assignment(project=project, name=name)\n    instance = instances.get(name, None)\n    if instances is None:\n        console.print(f\"Workstation {name} not found.\")\n        return\n    console.print(f\"Logs for instance: {instance.get('instance_name')} opening\")\n    webbrowser.open(instance.get(\"logs_url\"))\n</code></pre>"},{"location":"api/#workstation.cli.crud.start","title":"<code>start(context, name, code, browser, **kwargs)</code>","text":"<p>Start workstation and optionally open it either locally with VSCode or through VSCode in a browser.</p> Source code in <code>src/workstation/cli/crud.py</code> <pre><code>@command()\n@click.option(\n    \"-n\",\n    \"--name\",\n    help=\"Name of the workstation to start.\",\n    type=str,\n    metavar=\"&lt;str&gt;\",\n    required=True,\n)\n@click.option(\n    \"--code\",\n    help=\"Open workstation in VSCode locally. \"\n    \"This requires setup illustrated in \"\n    \"https://workstation.mlds.cash/#connect-to-a-workstation-with-local-vs-code\",\n    is_flag=True,\n    default=False,\n)\n@click.option(\n    \"--browser\",\n    help=\"Open workstation with a remote VSCode session in a web browser.\",\n    is_flag=True,\n    default=False,\n)\n@click.pass_context\ndef start(context: click.Context, name: str, code: bool, browser: bool, **kwargs):\n    \"\"\"Start workstation and optionally open it either locally with VSCode or through VSCode in a browser.\"\"\"\n    # Make sure the user is authenticated\n    check_gcloud_auth()\n\n    if code and browser:\n        raise ValueError(\n            \"Select either local VSCode (--code) or remote VSCode in web browser (--browser).\"\n        )\n\n    workstation_details = config_manager.read_configuration(name)\n\n    response = start_workstation(**workstation_details)\n    url = f\"https://80-{response.host}\"\n    if not code and not browser:\n        console.print(\n            \"Use --browser or --code to open the workstation in browser or vs code directly.\"\n        )\n        console.print(url)\n    elif code:\n        url = f\"vscode://vscode-remote/ssh-remote+{name}/home/{getpass.getuser()}\"\n        console.print(\"Opening workstation in VSCode...\")\n        webbrowser.open(url)\n    elif browser:\n        console.print(f\"Opening workstation at {url}...\")\n        webbrowser.open(url)\n</code></pre>"},{"location":"api/#workstation.cli.crud.stop","title":"<code>stop(context, **kwargs)</code>","text":"<p>Stop workstation.</p> Source code in <code>src/workstation/cli/crud.py</code> <pre><code>@command()\n@click.option(\n    \"-n\",\n    \"--name\",\n    help=\"Name of the workstation to stop.\",\n    type=str,\n    metavar=\"&lt;str&gt;\",\n)\n@click.pass_context\ndef stop(context: click.Context, **kwargs):\n    \"\"\"Stop workstation.\"\"\"\n    # Make sure the user is authenticated\n    check_gcloud_auth()\n\n    workstation_details = config_manager.read_configuration(kwargs[\"name\"])\n    response = stop_workstation(**workstation_details)\n    console.print(response.name, response.state)\n</code></pre>"},{"location":"api/#workstation.cli.crud.sync","title":"<code>sync(context, name, **kwargs)</code>","text":"<p>Sync files to workstation.</p> Source code in <code>src/workstation/cli/crud.py</code> <pre><code>@command()\n@click.option(\n    \"-n\",\n    \"--name\",\n    help=\"Name of the workstation to sync.\",\n    type=str,\n    metavar=\"&lt;str&gt;\",\n)\n@click.pass_context\ndef sync(\n    context: click.Context,\n    name: str,\n    **kwargs,\n):\n    \"\"\"Sync files to workstation.\"\"\"\n    # Make sure the user is authenticated\n    check_gcloud_auth()\n\n    # TDOO: Add source and destination options\n    source = \"~/remote-machines/workstation/\"\n    destination = \"~/\"\n\n    workstation_details = config_manager.read_configuration(name)\n\n    result = sync_files_workstation(\n        source=source,\n        destination=destination,\n        **workstation_details,\n    )\n\n    for line in result.stdout.split(\"\\n\"):\n        console.print(line)\n    if result.returncode != 0:\n        console.print(result.args)\n        console.print(result.stderr)\n</code></pre>"},{"location":"api/#workstation.config","title":"<code>config</code>","text":""},{"location":"api/#workstation.config.ConfigManager","title":"<code>ConfigManager</code>","text":"<p>A class to manage Workstation configurations.</p> <p>Attributes:</p> Name Type Description <code>workstation_data_dir</code> <code>Path</code> <p>The directory where workstation data is stored.</p> <code>workstation_configs</code> <code>Path</code> <p>The directory where individual workstation configurations are stored.</p> <p>Methods:</p> Name Description <code>check_if_config_exists</code> <p>Checks if a configuration file with the given name exists.</p> <code>write_configuration</code> <p>Writes the configuration to a YAML file and returns the path to it.</p> <code>read_configuration</code> <p>Reads the configuration for the given name and returns it as a dictionary.</p> <code>delete_configuration</code> <p>Deletes the configuration file and its corresponding YAML file for the given name.</p> <code>write_ssh_config</code> <p>Writes the SSH configuration for the workstation.</p> Source code in <code>src/workstation/config.py</code> <pre><code>class ConfigManager:\n    \"\"\"A class to manage Workstation configurations.\n\n    Attributes\n    ----------\n    workstation_data_dir : Path\n        The directory where workstation data is stored.\n    workstation_configs : Path\n        The directory where individual workstation configurations are stored.\n\n    Methods\n    -------\n    check_if_config_exists(name: str) -&gt; bool\n        Checks if a configuration file with the given name exists.\n    write_configuration(project: str, name: str, location: str, cluster: str, config: str) -&gt; Path\n        Writes the configuration to a YAML file and returns the path to it.\n    read_configuration(name: str) -&gt; dict\n        Reads the configuration for the given name and returns it as a dictionary.\n    delete_configuration(name: str) -&gt; None\n        Deletes the configuration file and its corresponding YAML file for the given name.\n    write_ssh_config(name: str, user: str, project: str, cluster: str, config: str, region: str)\n        Writes the SSH configuration for the workstation.\n    \"\"\"\n\n    def __init__(self):\n        self.workstation_data_dir = Path.home() / \".workstations\"\n        self.workstation_configs = self.workstation_data_dir / \"configs\"\n\n    def check_if_config_exists(self, name: str) -&gt; bool:\n        \"\"\"Check if a configuration file with the given name exists.\n\n        Parameters\n        ----------\n        name : str\n            The name of the configuration to check.\n\n        Returns\n        -------\n        bool\n            True if the configuration exists, False otherwise.\n        \"\"\"\n        return (self.workstation_configs / (name + \".yml\")).exists()\n\n    def write_configuration(\n        self, project: str, name: str, location: str, cluster: str, config: str\n    ) -&gt; Path:\n        \"\"\"Write the configuration to a YAML file.\n\n        Parameters\n        ----------\n        project : str\n            The project name.\n        name : str\n            The name of the workstation.\n        location : str\n            The location of the workstation.\n        cluster : str\n            The cluster associated with the workstation.\n        config : str\n            The specific configuration settings.\n\n        Returns\n        -------\n        Path\n            The path to the written YAML file.\n\n        Raises\n        ------\n        Exception\n            If any error occurs during the writing process.\n        \"\"\"\n        self.workstation_configs.mkdir(parents=True, exist_ok=True)\n\n        current_dir = Path.cwd()\n        os.chdir(self.workstation_configs)\n        try:\n            workstation = WorkstationConfig(\n                project=project,\n                name=name,\n                location=location,\n                cluster=cluster,\n                config=config,\n            )\n\n            workstation_path = workstation.generate_workstation_yml()\n            return self.workstation_configs / workstation_path\n        except Exception as e:\n            os.chdir(current_dir)\n            raise e\n\n    def read_configuration(self, name: str) -&gt; dict:\n        \"\"\"Read the configuration for the given name.\n\n        Parameters\n        ----------\n        name : str\n            The name of the configuration to read.\n\n        Returns\n        -------\n        dict\n            The contents of the configuration file as a dictionary.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the configuration file does not exist.\n        KeyError\n            If required keys are missing from the configuration file.\n        \"\"\"\n        workstation_config = self.workstation_configs / (name + \".yml\")\n\n        if not workstation_config.exists():\n            raise FileNotFoundError(\n                f\"Configuration {name} not found, please check if {workstation_config} exists.\"\n            )\n\n        with open(workstation_config, \"r\") as file:\n            contents = yaml.safe_load(file)\n\n        # check that project, name, location, cluster, and config are in the file\n        # For the error say what keys are missing\n        if not all(\n            key in contents\n            for key in [\"project\", \"name\", \"location\", \"cluster\", \"config\"]\n        ):\n            missing_keys = [\n                key\n                for key in [\"project\", \"name\", \"location\", \"cluster\", \"config\"]\n                if key not in contents\n            ]\n            raise KeyError(f\"Configuration file {name} is missing keys {missing_keys}\")\n\n        return contents\n\n    def delete_configuration(self, name: str) -&gt; None:\n        \"\"\"Delete the configuration file and its corresponding YAML file.\n\n        Parameters\n        ----------\n        name : str\n            The name of the configuration to delete.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the configuration file does not exist.\n        \"\"\"\n        workstation_yml = self.workstation_configs / (name + \".yml\")\n        workstation_config = self.workstation_configs / (name + \".config\")\n\n        if not workstation_config.exists():\n            raise FileNotFoundError(f\"Configuration {name} not found\")\n        if not workstation_yml.exists():\n            raise FileNotFoundError(f\"Configuration {name} not found\")\n\n        workstation_config.unlink()\n        workstation_yml.unlink()\n\n    def write_ssh_config(\n        self,\n        name: str,\n        user: str,\n        project: str,\n        cluster: str,\n        config: str,\n        region: str,\n    ):\n        \"\"\"Write the SSH configuration for the workstation.\n\n        Parameters\n        ----------\n        name : str\n            The name of the workstation.\n        user : str\n            The user for SSH connection.\n        project : str\n            The project name.\n        cluster : str\n            The cluster associated with the workstation.\n        config : str\n            The specific configuration settings.\n        region : str\n            The region where the workstation is deployed.\n\n        Raises\n        ------\n        NoPortFree\n            If no free port is found after checking 20 ports.\n        \"\"\"\n        workstation_config = self.workstation_configs / (name + \".config\")\n\n        # get all of the ports that are currently in use from the config files\n        ports = []\n        for config_file in self.workstation_configs.glob(\"*.config\"):\n            with open(config_file, \"r\") as file:\n                contents = file.read()\n                # Check if the match is not None before calling group\n                match = re.search(r\"\\n\\s*Port\\s+(\\d+)\", contents)\n                if match is not None:\n                    port = int(match.group(1))\n                    ports.append(port)\n\n        if len(ports) == 0:\n            port = 6000\n        else:\n            port = max(ports) + 1\n\n        for _ in range(20):\n            if check_socket(\"localhost\", port):\n                break\n            port += 1\n        else:\n            raise NoPortFree(\"Could not find a free port after checking 20 ports.\")\n\n        proxy_command = (\n            \"sh -c '\"\n            \"cleanup() { pkill -P $$; }; \"\n            \"trap cleanup EXIT; \"\n            \"gcloud workstations start-tcp-tunnel \"\n            f\"--project={project} \"\n            f\"--cluster={cluster} \"\n            f\"--config={config} \"\n            f\"--region={region} \"\n            \"--local-host-port=localhost:%p %h 22 &amp; \"\n            \"timeout=10; \"\n            \"while ! nc -z localhost %p; do \"\n            \"sleep 1; \"\n            \"timeout=$((timeout - 1)); \"\n            \"if [ $timeout -le 0 ]; then \"\n            \"exit 1; \"\n            \"fi; \"\n            \"done; \"\n            \"nc localhost %p'\"\n        )\n\n        config_content = dedent(\n            f\"\"\"\n            Host {name}\n                HostName {name}\n                Port {port}\n                User {user}\n                StrictHostKeyChecking no\n                UserKnownHostsFile /dev/null\n                ControlMaster auto\n                ControlPersist 30m\n                ControlPath ~/.ssh/cm/%r@%h:%p\n                ProxyCommand {proxy_command}\n                \"\"\"\n        ).strip()\n\n        with open(workstation_config, \"w\") as file:\n            file.write(config_content)\n</code></pre>"},{"location":"api/#workstation.config.ConfigManager.check_if_config_exists","title":"<code>check_if_config_exists(name)</code>","text":"<p>Check if a configuration file with the given name exists.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the configuration exists, False otherwise.</p> Source code in <code>src/workstation/config.py</code> <pre><code>def check_if_config_exists(self, name: str) -&gt; bool:\n    \"\"\"Check if a configuration file with the given name exists.\n\n    Parameters\n    ----------\n    name : str\n        The name of the configuration to check.\n\n    Returns\n    -------\n    bool\n        True if the configuration exists, False otherwise.\n    \"\"\"\n    return (self.workstation_configs / (name + \".yml\")).exists()\n</code></pre>"},{"location":"api/#workstation.config.ConfigManager.delete_configuration","title":"<code>delete_configuration(name)</code>","text":"<p>Delete the configuration file and its corresponding YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration to delete.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the configuration file does not exist.</p> Source code in <code>src/workstation/config.py</code> <pre><code>def delete_configuration(self, name: str) -&gt; None:\n    \"\"\"Delete the configuration file and its corresponding YAML file.\n\n    Parameters\n    ----------\n    name : str\n        The name of the configuration to delete.\n\n    Raises\n    ------\n    FileNotFoundError\n        If the configuration file does not exist.\n    \"\"\"\n    workstation_yml = self.workstation_configs / (name + \".yml\")\n    workstation_config = self.workstation_configs / (name + \".config\")\n\n    if not workstation_config.exists():\n        raise FileNotFoundError(f\"Configuration {name} not found\")\n    if not workstation_yml.exists():\n        raise FileNotFoundError(f\"Configuration {name} not found\")\n\n    workstation_config.unlink()\n    workstation_yml.unlink()\n</code></pre>"},{"location":"api/#workstation.config.ConfigManager.read_configuration","title":"<code>read_configuration(name)</code>","text":"<p>Read the configuration for the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the configuration to read.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The contents of the configuration file as a dictionary.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the configuration file does not exist.</p> <code>KeyError</code> <p>If required keys are missing from the configuration file.</p> Source code in <code>src/workstation/config.py</code> <pre><code>def read_configuration(self, name: str) -&gt; dict:\n    \"\"\"Read the configuration for the given name.\n\n    Parameters\n    ----------\n    name : str\n        The name of the configuration to read.\n\n    Returns\n    -------\n    dict\n        The contents of the configuration file as a dictionary.\n\n    Raises\n    ------\n    FileNotFoundError\n        If the configuration file does not exist.\n    KeyError\n        If required keys are missing from the configuration file.\n    \"\"\"\n    workstation_config = self.workstation_configs / (name + \".yml\")\n\n    if not workstation_config.exists():\n        raise FileNotFoundError(\n            f\"Configuration {name} not found, please check if {workstation_config} exists.\"\n        )\n\n    with open(workstation_config, \"r\") as file:\n        contents = yaml.safe_load(file)\n\n    # check that project, name, location, cluster, and config are in the file\n    # For the error say what keys are missing\n    if not all(\n        key in contents\n        for key in [\"project\", \"name\", \"location\", \"cluster\", \"config\"]\n    ):\n        missing_keys = [\n            key\n            for key in [\"project\", \"name\", \"location\", \"cluster\", \"config\"]\n            if key not in contents\n        ]\n        raise KeyError(f\"Configuration file {name} is missing keys {missing_keys}\")\n\n    return contents\n</code></pre>"},{"location":"api/#workstation.config.ConfigManager.write_configuration","title":"<code>write_configuration(project, name, location, cluster, config)</code>","text":"<p>Write the configuration to a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The project name.</p> required <code>name</code> <code>str</code> <p>The name of the workstation.</p> required <code>location</code> <code>str</code> <p>The location of the workstation.</p> required <code>cluster</code> <code>str</code> <p>The cluster associated with the workstation.</p> required <code>config</code> <code>str</code> <p>The specific configuration settings.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path to the written YAML file.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If any error occurs during the writing process.</p> Source code in <code>src/workstation/config.py</code> <pre><code>def write_configuration(\n    self, project: str, name: str, location: str, cluster: str, config: str\n) -&gt; Path:\n    \"\"\"Write the configuration to a YAML file.\n\n    Parameters\n    ----------\n    project : str\n        The project name.\n    name : str\n        The name of the workstation.\n    location : str\n        The location of the workstation.\n    cluster : str\n        The cluster associated with the workstation.\n    config : str\n        The specific configuration settings.\n\n    Returns\n    -------\n    Path\n        The path to the written YAML file.\n\n    Raises\n    ------\n    Exception\n        If any error occurs during the writing process.\n    \"\"\"\n    self.workstation_configs.mkdir(parents=True, exist_ok=True)\n\n    current_dir = Path.cwd()\n    os.chdir(self.workstation_configs)\n    try:\n        workstation = WorkstationConfig(\n            project=project,\n            name=name,\n            location=location,\n            cluster=cluster,\n            config=config,\n        )\n\n        workstation_path = workstation.generate_workstation_yml()\n        return self.workstation_configs / workstation_path\n    except Exception as e:\n        os.chdir(current_dir)\n        raise e\n</code></pre>"},{"location":"api/#workstation.config.ConfigManager.write_ssh_config","title":"<code>write_ssh_config(name, user, project, cluster, config, region)</code>","text":"<p>Write the SSH configuration for the workstation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the workstation.</p> required <code>user</code> <code>str</code> <p>The user for SSH connection.</p> required <code>project</code> <code>str</code> <p>The project name.</p> required <code>cluster</code> <code>str</code> <p>The cluster associated with the workstation.</p> required <code>config</code> <code>str</code> <p>The specific configuration settings.</p> required <code>region</code> <code>str</code> <p>The region where the workstation is deployed.</p> required <p>Raises:</p> Type Description <code>NoPortFree</code> <p>If no free port is found after checking 20 ports.</p> Source code in <code>src/workstation/config.py</code> <pre><code>def write_ssh_config(\n    self,\n    name: str,\n    user: str,\n    project: str,\n    cluster: str,\n    config: str,\n    region: str,\n):\n    \"\"\"Write the SSH configuration for the workstation.\n\n    Parameters\n    ----------\n    name : str\n        The name of the workstation.\n    user : str\n        The user for SSH connection.\n    project : str\n        The project name.\n    cluster : str\n        The cluster associated with the workstation.\n    config : str\n        The specific configuration settings.\n    region : str\n        The region where the workstation is deployed.\n\n    Raises\n    ------\n    NoPortFree\n        If no free port is found after checking 20 ports.\n    \"\"\"\n    workstation_config = self.workstation_configs / (name + \".config\")\n\n    # get all of the ports that are currently in use from the config files\n    ports = []\n    for config_file in self.workstation_configs.glob(\"*.config\"):\n        with open(config_file, \"r\") as file:\n            contents = file.read()\n            # Check if the match is not None before calling group\n            match = re.search(r\"\\n\\s*Port\\s+(\\d+)\", contents)\n            if match is not None:\n                port = int(match.group(1))\n                ports.append(port)\n\n    if len(ports) == 0:\n        port = 6000\n    else:\n        port = max(ports) + 1\n\n    for _ in range(20):\n        if check_socket(\"localhost\", port):\n            break\n        port += 1\n    else:\n        raise NoPortFree(\"Could not find a free port after checking 20 ports.\")\n\n    proxy_command = (\n        \"sh -c '\"\n        \"cleanup() { pkill -P $$; }; \"\n        \"trap cleanup EXIT; \"\n        \"gcloud workstations start-tcp-tunnel \"\n        f\"--project={project} \"\n        f\"--cluster={cluster} \"\n        f\"--config={config} \"\n        f\"--region={region} \"\n        \"--local-host-port=localhost:%p %h 22 &amp; \"\n        \"timeout=10; \"\n        \"while ! nc -z localhost %p; do \"\n        \"sleep 1; \"\n        \"timeout=$((timeout - 1)); \"\n        \"if [ $timeout -le 0 ]; then \"\n        \"exit 1; \"\n        \"fi; \"\n        \"done; \"\n        \"nc localhost %p'\"\n    )\n\n    config_content = dedent(\n        f\"\"\"\n        Host {name}\n            HostName {name}\n            Port {port}\n            User {user}\n            StrictHostKeyChecking no\n            UserKnownHostsFile /dev/null\n            ControlMaster auto\n            ControlPersist 30m\n            ControlPath ~/.ssh/cm/%r@%h:%p\n            ProxyCommand {proxy_command}\n            \"\"\"\n    ).strip()\n\n    with open(workstation_config, \"w\") as file:\n        file.write(config_content)\n</code></pre>"},{"location":"api/#workstation.config.WorkstationConfig","title":"<code>WorkstationConfig</code>  <code>dataclass</code>","text":"<p>A class to represent a Workstation\u2019s configuration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the workstation.</p> <code>location</code> <code>str</code> <p>The location where the workstation is deployed.</p> <code>cluster</code> <code>str</code> <p>The cluster associated with the workstation.</p> <code>config</code> <code>str</code> <p>The specific configuration settings of the workstation.</p> <code>project</code> <code>str</code> <p>The project associated with the workstation.</p> <p>Methods:</p> Name Description <code>generate_workstation_yml</code> <p>Generates a YAML configuration file for the workstation and saves it to the current directory.</p> Source code in <code>src/workstation/config.py</code> <pre><code>@dataclass\nclass WorkstationConfig:\n    \"\"\"A class to represent a Workstation's configuration.\n\n    Attributes\n    ----------\n    name : str\n        The name of the workstation.\n    location : str\n        The location where the workstation is deployed.\n    cluster : str\n        The cluster associated with the workstation.\n    config : str\n        The specific configuration settings of the workstation.\n    project : str\n        The project associated with the workstation.\n\n    Methods\n    -------\n    generate_workstation_yml() -&gt; Path\n        Generates a YAML configuration file for the workstation and saves it to the current directory.\n    \"\"\"\n\n    name: str\n    location: str\n    cluster: str\n    config: str\n    project: str\n\n    def generate_workstation_yml(self) -&gt; Path:\n        \"\"\"Generate a YAML configuration file for the workstation.\n\n        Returns\n        -------\n        Path\n            The path to the generated YAML file.\n        \"\"\"\n        write_path = Path(\".\", f\"{self.name}.yml\")\n        with open(write_path, \"w\") as file:\n            yaml.dump(asdict(self), file, sort_keys=False)\n\n        return write_path\n</code></pre>"},{"location":"api/#workstation.config.WorkstationConfig.generate_workstation_yml","title":"<code>generate_workstation_yml()</code>","text":"<p>Generate a YAML configuration file for the workstation.</p> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the generated YAML file.</p> Source code in <code>src/workstation/config.py</code> <pre><code>def generate_workstation_yml(self) -&gt; Path:\n    \"\"\"Generate a YAML configuration file for the workstation.\n\n    Returns\n    -------\n    Path\n        The path to the generated YAML file.\n    \"\"\"\n    write_path = Path(\".\", f\"{self.name}.yml\")\n    with open(write_path, \"w\") as file:\n        yaml.dump(asdict(self), file, sort_keys=False)\n\n    return write_path\n</code></pre>"},{"location":"api/#workstation.core","title":"<code>core</code>","text":""},{"location":"api/#workstation.core.create_workstation","title":"<code>create_workstation(project, location, cluster, config, name, account, user, proxy=None, no_proxy=None, envs=None)</code>","text":"<p>Create a new workstation with the specified configuration.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The Google Cloud project ID.</p> required <code>location</code> <code>str</code> <p>The Google Cloud location.</p> required <code>cluster</code> <code>str</code> <p>The workstation cluster name.</p> required <code>config</code> <code>str</code> <p>The workstation configuration name.</p> required <code>name</code> <code>str</code> <p>The name of the new workstation.</p> required <code>account</code> <code>str</code> <p>The account associated with the workstation.</p> required <code>user</code> <code>str</code> <p>The user associated with the workstation.</p> required <code>proxy</code> <code>Optional[str]</code> <p>Proxy settings, by default None.</p> <code>None</code> <code>no_proxy</code> <code>Optional[str]</code> <p>No-proxy settings, by default None.</p> <code>None</code> <code>envs</code> <code>Optional[Tuple[Tuple[str, str]]]</code> <p>Additional environment variables to set, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Workstation</code> <p>Response from the workstation creation request.</p> Source code in <code>src/workstation/core.py</code> <pre><code>def create_workstation(\n    project: str,\n    location: str,\n    cluster: str,\n    config: str,\n    name: str,\n    account: str,\n    user: str,\n    proxy: Optional[str] = None,\n    no_proxy: Optional[str] = None,\n    envs: Optional[Tuple[Tuple[str, str]]] = None,\n) -&gt; Workstation:\n    \"\"\"\n    Create a new workstation with the specified configuration.\n\n    Parameters\n    ----------\n    project : str\n        The Google Cloud project ID.\n    location : str\n        The Google Cloud location.\n    cluster : str\n        The workstation cluster name.\n    config : str\n        The workstation configuration name.\n    name : str\n        The name of the new workstation.\n    account : str\n        The account associated with the workstation.\n    user : str\n        The user associated with the workstation.\n    proxy : Optional[str], optional\n        Proxy settings, by default None.\n    no_proxy : Optional[str], optional\n        No-proxy settings, by default None.\n    envs : Optional[Tuple[Tuple[str, str]]], optional\n        Additional environment variables to set, by default None.\n\n    Returns\n    -------\n    Workstation\n        Response from the workstation creation request.\n    \"\"\"\n    client = workstations_v1beta.WorkstationsClient()\n    env = {\n        \"LDAP\": user,\n        \"ACCOUNT\": account,\n    }\n\n    if proxy:\n        env[\"http_proxy\"] = proxy\n        env[\"HTTPS_PROXY\"] = proxy\n        env[\"https_proxy\"] = proxy\n        env[\"HTTP_PROXY\"] = proxy\n        env[\"no_proxy\"] = no_proxy\n        env[\"NO_PROXY\"] = no_proxy\n\n    if envs:\n        user_envs = dict(envs)\n        # ensure that no duplicate keys are added to env\n        for key, value in user_envs.items():\n            if key not in env:\n                env[key] = value\n            else:\n                logger.warning(\n                    f\"Environment variable {key} already exists in the environment, skipping\"\n                )\n\n    request = workstations_v1beta.CreateWorkstationRequest(\n        parent=f\"projects/{project}/locations/{location}/workstationClusters/{cluster}/workstationConfigs/{config}\",\n        workstation_id=name,\n        workstation=Workstation(\n            display_name=name,\n            env=env,\n        ),\n    )\n\n    try:\n        operation = client.create_workstation(request=request)\n        response = operation.result()\n    except AlreadyExists:\n        console.print(f\"Workstation [bold blue]{name}[/bold blue] already exists\")\n        sys.exit(1)\n\n    config_manager.write_configuration(\n        project=project,\n        name=name,\n        location=location,\n        cluster=cluster,\n        config=config,\n    )\n\n    return response\n</code></pre>"},{"location":"api/#workstation.core.delete_workstation","title":"<code>delete_workstation(project, name, location, cluster, config)</code>","text":"<p>Delete an existing workstation.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The Google Cloud project ID.</p> required <code>name</code> <code>str</code> <p>The name of the workstation.</p> required <code>location</code> <code>str</code> <p>The Google Cloud location.</p> required <code>cluster</code> <code>str</code> <p>The workstation cluster name.</p> required <code>config</code> <code>str</code> <p>The workstation configuration name.</p> required <p>Returns:</p> Type Description <code>Operation</code> <p>Response from the workstation deletion request.</p> Source code in <code>src/workstation/core.py</code> <pre><code>def delete_workstation(\n    project: str,\n    name: str,\n    location: str,\n    cluster: str,\n    config: str,\n) -&gt; Operation:\n    \"\"\"\n    Delete an existing workstation.\n\n    Parameters\n    ----------\n    project : str\n        The Google Cloud project ID.\n    name : str\n        The name of the workstation.\n    location : str\n        The Google Cloud location.\n    cluster : str\n        The workstation cluster name.\n    config : str\n        The workstation configuration name.\n\n    Returns\n    -------\n    Operation\n        Response from the workstation deletion request.\n    \"\"\"\n    client = workstations_v1beta.WorkstationsClient()\n\n    request = workstations_v1beta.DeleteWorkstationRequest(\n        name=f\"projects/{project}/locations/{location}/workstationClusters/{cluster}/workstationConfigs/{config}/workstations/{name}\",\n    )\n\n    operation = client.delete_workstation(request=request)\n    console.print(\"Waiting for operation to complete...\")\n    response = operation.result()\n\n    return response\n</code></pre>"},{"location":"api/#workstation.core.list_workstation_clusters","title":"<code>list_workstation_clusters(project, location)</code>","text":"<p>List workstation clusters in a specific project and location.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The Google Cloud project ID.</p> required <code>location</code> <code>str</code> <p>The Google Cloud location.</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>A list of workstation cluster configurations.</p> Source code in <code>src/workstation/core.py</code> <pre><code>def list_workstation_clusters(project: str, location: str) -&gt; List[Dict]:\n    \"\"\"\n    List workstation clusters in a specific project and location.\n\n    Parameters\n    ----------\n    project : str\n        The Google Cloud project ID.\n    location : str\n        The Google Cloud location.\n\n    Returns\n    -------\n    List[Dict]\n        A list of workstation cluster configurations.\n    \"\"\"\n    client = workstations_v1beta.WorkstationsClient()\n\n    request = workstations_v1beta.ListWorkstationClustersRequest(\n        parent=f\"projects/{project}/locations/{location}\",\n    )\n    page_result = client.list_workstation_clusters(request=request)\n\n    configs = []\n    for config in page_result:\n        configs.append(\n            {\n                \"name\": config.name,\n                \"image\": config.subnetwork,\n            }\n        )\n    return configs\n</code></pre>"},{"location":"api/#workstation.core.list_workstation_configs","title":"<code>list_workstation_configs(project, location, cluster)</code>","text":"<p>List usable workstation configurations in a specific project, location, and cluster.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The Google Cloud project ID.</p> required <code>location</code> <code>str</code> <p>The Google Cloud location.</p> required <code>cluster</code> <code>str</code> <p>The workstation cluster name.</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>A list of usable workstation configurations.</p> Source code in <code>src/workstation/core.py</code> <pre><code>def list_workstation_configs(project: str, location: str, cluster: str) -&gt; List[Dict]:\n    \"\"\"\n    List usable workstation configurations in a specific project, location, and cluster.\n\n    Parameters\n    ----------\n    project : str\n        The Google Cloud project ID.\n    location : str\n        The Google Cloud location.\n    cluster : str\n        The workstation cluster name.\n\n    Returns\n    -------\n    List[Dict]\n        A list of usable workstation configurations.\n    \"\"\"\n    client = workstations_v1beta.WorkstationsClient()\n\n    request = workstations_v1beta.ListUsableWorkstationConfigsRequest(\n        parent=f\"projects/{project}/locations/{location}/workstationClusters/{cluster}\",\n    )\n    page_result = client.list_usable_workstation_configs(request=request)\n\n    configs = []\n    for config in page_result:\n        if config.host.gce_instance.machine_type not in machine_types:\n            logger.debug(\n                f\"{config.host.gce_instance.machine_type} not exist in machine_types in machines.py\"\n            )\n            continue\n        machine_details = machine_types[config.host.gce_instance.machine_type]\n        machine_specs = f\"machine_specs[{machine_details['vCPUs']} vCPUs, {machine_details['Memory (GB)']} GB]\"\n        configs.append(\n            {\n                \"name\": config.name,\n                \"image\": config.container.image,\n                \"machine_type\": config.host.gce_instance.machine_type,\n                \"idle_timeout\": config.idle_timeout.total_seconds(),\n                \"max_runtime\": config.running_timeout.total_seconds(),\n                \"machine_specs\": machine_specs,\n            }\n        )\n    return configs\n</code></pre>"},{"location":"api/#workstation.core.list_workstations","title":"<code>list_workstations(project, location, cluster)</code>","text":"<p>List all workstations in a specific project, location, and cluster.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The Google Cloud project ID.</p> required <code>location</code> <code>str</code> <p>The Google Cloud location.</p> required <code>cluster</code> <code>str</code> <p>The workstation cluster name.</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>A list of workstation configurations.</p> Source code in <code>src/workstation/core.py</code> <pre><code>def list_workstations(project: str, location: str, cluster: str) -&gt; List[Dict]:\n    \"\"\"\n    List all workstations in a specific project, location, and cluster.\n\n    Parameters\n    ----------\n    project : str\n        The Google Cloud project ID.\n    location : str\n        The Google Cloud location.\n    cluster : str\n        The workstation cluster name.\n\n    Returns\n    -------\n    List[Dict]\n        A list of workstation configurations.\n    \"\"\"\n    configs = list_workstation_configs(\n        project=project, location=location, cluster=cluster\n    )\n\n    client = workstations_v1beta.WorkstationsClient()\n    workstations = []\n\n    for config in configs:\n        request = workstations_v1beta.ListWorkstationsRequest(\n            parent=config.get(\"name\"),\n        )\n\n        page_result = client.list_workstations(request=request)\n\n        for workstation in page_result:\n            workstations.append(\n                {\n                    \"name\": workstation.name,\n                    \"state\": workstation.state,\n                    \"env\": workstation.env,\n                    \"config\": config,\n                    \"project\": project,\n                    \"location\": location,\n                    \"cluster\": cluster,\n                }\n            )\n    return workstations\n</code></pre>"},{"location":"api/#workstation.core.start_workstation","title":"<code>start_workstation(project, name, location, cluster, config)</code>","text":"<p>Start an existing workstation.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The Google Cloud project ID.</p> required <code>name</code> <code>str</code> <p>The name of the workstation.</p> required <code>location</code> <code>str</code> <p>The Google Cloud location.</p> required <code>cluster</code> <code>str</code> <p>The workstation cluster name.</p> required <code>config</code> <code>str</code> <p>The workstation configuration name.</p> required <p>Returns:</p> Type Description <code>Operation</code> <p>Response from the workstation start request.</p> Source code in <code>src/workstation/core.py</code> <pre><code>def start_workstation(\n    project: str,\n    name: str,\n    location: str,\n    cluster: str,\n    config: str,\n) -&gt; Operation:\n    \"\"\"\n    Start an existing workstation.\n\n    Parameters\n    ----------\n    project : str\n        The Google Cloud project ID.\n    name : str\n        The name of the workstation.\n    location : str\n        The Google Cloud location.\n    cluster : str\n        The workstation cluster name.\n    config : str\n        The workstation configuration name.\n\n    Returns\n    -------\n    Operation\n        Response from the workstation start request.\n    \"\"\"\n    client = workstations_v1beta.WorkstationsClient()\n\n    request = workstations_v1beta.StartWorkstationRequest(\n        name=f\"projects/{project}/locations/{location}/workstationClusters/{cluster}/workstationConfigs/{config}/workstations/{name}\",\n    )\n\n    operation = client.start_workstation(request=request)\n    console.print(\"Waiting for operation to complete (~3 minutes)...\")\n    response = operation.result()\n\n    return response\n</code></pre>"},{"location":"api/#workstation.core.stop_workstation","title":"<code>stop_workstation(project, name, location, cluster, config)</code>","text":"<p>Stop an existing workstation.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The Google Cloud project ID.</p> required <code>name</code> <code>str</code> <p>The name of the workstation.</p> required <code>location</code> <code>str</code> <p>The Google Cloud location.</p> required <code>cluster</code> <code>str</code> <p>The workstation cluster name.</p> required <code>config</code> <code>str</code> <p>The workstation configuration name.</p> required <p>Returns:</p> Type Description <code>Operation</code> <p>Response from the workstation stop request.</p> Source code in <code>src/workstation/core.py</code> <pre><code>def stop_workstation(\n    project: str,\n    name: str,\n    location: str,\n    cluster: str,\n    config: str,\n) -&gt; Operation:\n    \"\"\"\n    Stop an existing workstation.\n\n    Parameters\n    ----------\n    project : str\n        The Google Cloud project ID.\n    name : str\n        The name of the workstation.\n    location : str\n        The Google Cloud location.\n    cluster : str\n        The workstation cluster name.\n    config : str\n        The workstation configuration name.\n\n    Returns\n    -------\n    Operation\n        Response from the workstation stop request.\n    \"\"\"\n    client = workstations_v1beta.WorkstationsClient()\n\n    request = workstations_v1beta.StopWorkstationRequest(\n        name=f\"projects/{project}/locations/{location}/workstationClusters/{cluster}/workstationConfigs/{config}/workstations/{name}\",\n    )\n\n    operation = client.stop_workstation(request=request)\n    console.print(\"Waiting for operation to complete...\")\n    response = operation.result()\n\n    return response\n</code></pre>"},{"location":"api/#workstation.utils","title":"<code>utils</code>","text":""},{"location":"api/#workstation.utils.NoPortFree","title":"<code>NoPortFree</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when no free port is available for the SSH tunnel.</p> Source code in <code>src/workstation/utils.py</code> <pre><code>class NoPortFree(Exception):\n    \"\"\"Exception raised when no free port is available for the SSH tunnel.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#workstation.utils.check_gcloud_auth","title":"<code>check_gcloud_auth()</code>","text":"<p>Check if the current gcloud CLI is authenticated and refresh if necessary.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if authentication is successful, False otherwise.</p> <p>Raises:</p> Type Description <code>SystemExit</code> <p>If reauthentication is needed.</p> Source code in <code>src/workstation/utils.py</code> <pre><code>def check_gcloud_auth():\n    \"\"\"\n    Check if the current gcloud CLI is authenticated and refresh if necessary.\n\n    Returns\n    -------\n    bool\n        True if authentication is successful, False otherwise.\n\n    Raises\n    ------\n    SystemExit\n        If reauthentication is needed.\n    \"\"\"\n    from google.auth import default\n\n    try:\n        credentials, project = google.auth.default()\n\n        # Check if the credentials are valid and refresh if necessary\n        if credentials.requires_scopes:\n            credentials = credentials.with_scopes(\n                [\"https://www.googleapis.com/auth/cloud-platform\"]\n            )\n\n        credentials.refresh(Request())\n        return True\n\n    except (DefaultCredentialsError, RefreshError):\n        console.print(\n            \"Reauthentication is needed. Please run [bold blue]gcloud auth login &amp; gcloud auth application-default login[/bold blue].\"\n        )\n        sys.exit(1)\n</code></pre>"},{"location":"api/#workstation.utils.check_socket","title":"<code>check_socket(host, port)</code>","text":"<p>Check if a socket on the given host and port is available.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The hostname or IP address.</p> required <code>port</code> <code>int</code> <p>The port number.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the socket is available, False otherwise.</p> Source code in <code>src/workstation/utils.py</code> <pre><code>def check_socket(host, port):\n    \"\"\"\n    Check if a socket on the given host and port is available.\n\n    Parameters\n    ----------\n    host : str\n        The hostname or IP address.\n    port : int\n        The port number.\n\n    Returns\n    -------\n    bool\n        True if the socket is available, False otherwise.\n    \"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    try:\n        s.bind((host, port))\n        return True\n    except socket.error:\n        return False\n    finally:\n        s.close()\n</code></pre>"},{"location":"api/#workstation.utils.config_tree","title":"<code>config_tree(configs)</code>","text":"<p>Generate a tree structure for displaying workstation configurations using Rich library.</p> <p>Parameters:</p> Name Type Description Default <code>configs</code> <code>list</code> <p>A list of workstation configurations.</p> required <p>Returns:</p> Type Description <code>Tree</code> <p>A Rich Tree object representing the configurations.</p> Source code in <code>src/workstation/utils.py</code> <pre><code>def config_tree(configs: list) -&gt; Tree:\n    \"\"\"\n    Generate a tree structure for displaying workstation configurations using Rich library.\n\n    Parameters\n    ----------\n    configs : list\n        A list of workstation configurations.\n\n    Returns\n    -------\n    Tree\n        A Rich Tree object representing the configurations.\n    \"\"\"\n    tree = Tree(\"Configs\", style=\"bold blue\")\n\n    for config in configs:\n        config_branch = tree.add(f\"Config: {config['name'].split('/')[-1]}\")\n        config_branch.add(f\":minidisc: Image: {config['image']}\")\n        config_branch.add(f\":computer: Machine Type: {config['machine_type']}\")\n        config_branch.add(f\":computer: Machine Specs: {config['machine_specs']}\")\n        config_branch.add(\n            f\":hourglass_flowing_sand: Idle Timeout (s): {str(config['idle_timeout'])}\"\n        )\n        config_branch.add(\n            f\":hourglass_flowing_sand: Max Runtime (s): {str(config['max_runtime'])}\"\n        )\n\n    return tree\n</code></pre>"},{"location":"api/#workstation.utils.default_serializer","title":"<code>default_serializer(obj)</code>","text":"<p>Handle specific object types that are not serializable by default.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to serialize.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Serialized object (e.g., dictionary).</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the object type is not serializable.</p> Source code in <code>src/workstation/utils.py</code> <pre><code>def default_serializer(obj):\n    \"\"\"\n    Handle specific object types that are not serializable by default.\n\n    Parameters\n    ----------\n    obj : Any\n        The object to serialize.\n\n    Returns\n    -------\n    Any\n        Serialized object (e.g., dictionary).\n\n    Raises\n    ------\n    TypeError\n        If the object type is not serializable.\n    \"\"\"\n    # Handle protobuf ScalarMapContainer\n    if hasattr(obj, \"MapContainer\") or \"google._upb._message.ScalarMapContainer\" in str(\n        type(obj)\n    ):\n        # Convert and filter out non-essential attributes\n        return {\n            key: value for key, value in obj.__dict__.items() if key != \"MapContainer\"\n        }\n    raise TypeError(f\"Type {type(obj)} not serializable\")\n</code></pre>"},{"location":"api/#workstation.utils.get_instance_assignment","title":"<code>get_instance_assignment(project, name)</code>","text":"<p>Get the instance assignment log entries for a specific workstation.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The Google Cloud project ID.</p> required <code>name</code> <code>str</code> <p>The name of the workstation.</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>A dictionary of log entries related to the instance assignment.</p> Source code in <code>src/workstation/utils.py</code> <pre><code>def get_instance_assignment(project: str, name: str):\n    \"\"\"\n    Get the instance assignment log entries for a specific workstation.\n\n    Parameters\n    ----------\n    project : str\n        The Google Cloud project ID.\n    name : str\n        The name of the workstation.\n\n    Returns\n    -------\n    Dict\n        A dictionary of log entries related to the instance assignment.\n    \"\"\"\n    check_gcloud_auth()\n    client = cloud_logging.Client(project=project)\n\n    timestamp = (datetime.now(timezone.utc) - timedelta(days=1)).isoformat()\n\n    filter_str = (\n        f'logName=\"projects/{project}/logs/workstations.googleapis.com%2Fvm_assignments\" '\n        f'AND timestamp &gt;= \"{timestamp}\"'\n    )\n\n    entries = client.list_entries(filter_=filter_str)\n\n    log_entries_dict = {}\n\n    for entry in entries:\n        try:\n            workstation_id, log_entry = process_entry(entry, project)\n            log_entries_dict[workstation_id] = log_entry\n            if workstation_id == name:\n                return log_entries_dict\n        except Exception as exc:\n            print(f\"Entry {entry} generated an exception: {exc}\")\n\n    return log_entries_dict\n</code></pre>"},{"location":"api/#workstation.utils.get_logger","title":"<code>get_logger()</code>","text":"<p>Set log level from LOG_LEVEL environment variable, default to INFO.</p> <p>This is useful for debugging purpose. The value of LOG_LEVEL should be one of these: \u2018DEBUG\u2019, \u2018INFO\u2019, \u2018WARNING\u2019, \u2018ERROR\u2019, \u2018CRITICAL\u2019.</p> Source code in <code>src/workstation/utils.py</code> <pre><code>def get_logger():\n    \"\"\"\n    Set log level from LOG_LEVEL environment variable, default to INFO.\n\n    This is useful for debugging purpose.\n    The value of LOG_LEVEL should be one of these: 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'.\n    \"\"\"\n    log_level = os.getenv(\"LOG_LEVEL\", \"INFO\").upper()\n    logger = logging.getLogger(__name__)\n    logger.setLevel(log_level)\n\n    # Avoid adding multiple handlers\n    if not logger.handlers:\n        handler = logging.StreamHandler()  # Log to console\n        handler.setLevel(log_level)\n        formatter = logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\")\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n    return logger\n</code></pre>"},{"location":"api/#workstation.utils.process_entry","title":"<code>process_entry(entry, project)</code>","text":"<p>Process a log entry to extract workstation information.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <p>A log entry object.</p> required <code>project</code> <code>str</code> <p>The Google Cloud project ID.</p> required <p>Returns:</p> Type Description <code>Tuple[str, Dict]</code> <p>Workstation ID and a dictionary with instance information.</p> Source code in <code>src/workstation/utils.py</code> <pre><code>def process_entry(entry, project):\n    \"\"\"\n    Process a log entry to extract workstation information.\n\n    Parameters\n    ----------\n    entry\n        A log entry object.\n    project : str\n        The Google Cloud project ID.\n\n    Returns\n    -------\n    Tuple[str, Dict]\n        Workstation ID and a dictionary with instance information.\n    \"\"\"\n    workstation_id = entry.resource.labels.get(\"workstation_id\")\n    instance_name = entry.labels.get(\"instance_name\")\n    instance_id = entry.labels.get(\"instance_id\")\n\n    resource_type = \"gce_instance\"\n    base_url = f\"https://console.cloud.google.com/logs/query;query=resource.type%3D%22{resource_type}%22%0Aresource.labels.instance_id%3D%22\"\n    url = f\"{base_url}{instance_id}%22?project={project}\"\n\n    log_entry = {\n        \"instance_name\": instance_name,\n        \"instance_id\": instance_id,\n        \"logs_url\": url,\n    }\n\n    return workstation_id, log_entry\n</code></pre>"},{"location":"api/#workstation.utils.read_gcloud_config","title":"<code>read_gcloud_config()</code>","text":"<p>Read the default Google Cloud configuration.</p> <p>Returns:</p> Type Description <code>Tuple[str, str, str]</code> <p>Default project ID, location, and account from gcloud configuration.</p> Source code in <code>src/workstation/utils.py</code> <pre><code>def read_gcloud_config():\n    \"\"\"\n    Read the default Google Cloud configuration.\n\n    Returns\n    -------\n    Tuple[str, str, str]\n        Default project ID, location, and account from gcloud configuration.\n    \"\"\"\n    config_path = os.path.expanduser(\"~/.config/gcloud/configurations/config_default\")\n    config = configparser.ConfigParser()\n    config.read(config_path)\n\n    # Assuming the default settings are under the 'core' section\n    default_project = config.get(\"core\", \"project\", fallback=None)\n    default_location = config.get(\"compute\", \"region\", fallback=None)\n    account = config.get(\"core\", \"account\", fallback=None)\n\n    return default_project, default_location, account\n</code></pre>"},{"location":"api/#workstation.utils.sync_files_workstation","title":"<code>sync_files_workstation(project, name, location, cluster, config, source, destination)</code>","text":"<p>Synchronize files from the local system to the workstation using rsync over an SSH tunnel.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>str</code> <p>The Google Cloud project ID.</p> required <code>name</code> <code>str</code> <p>The name of the workstation.</p> required <code>location</code> <code>str</code> <p>The Google Cloud location.</p> required <code>cluster</code> <code>str</code> <p>The workstation cluster name.</p> required <code>config</code> <code>str</code> <p>The workstation configuration name.</p> required <code>source</code> <code>str</code> <p>The source directory on the local system.</p> required <code>destination</code> <code>str</code> <p>The destination directory on the workstation.</p> required <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>The result of the rsync command.</p> Source code in <code>src/workstation/utils.py</code> <pre><code>def sync_files_workstation(\n    project: str,\n    name: str,\n    location: str,\n    cluster: str,\n    config: str,\n    source: str,\n    destination: str,\n):\n    \"\"\"\n    Synchronize files from the local system to the workstation using rsync over an SSH tunnel.\n\n    Parameters\n    ----------\n    project : str\n        The Google Cloud project ID.\n    name : str\n        The name of the workstation.\n    location : str\n        The Google Cloud location.\n    cluster : str\n        The workstation cluster name.\n    config : str\n        The workstation configuration name.\n    source : str\n        The source directory on the local system.\n    destination : str\n        The destination directory on the workstation.\n\n    Returns\n    -------\n    subprocess.CompletedProcess\n        The result of the rsync command.\n    \"\"\"\n    port = 61000\n    for _ in range(20):\n        if check_socket(\"localhost\", port):\n            break\n        port += 1\n    else:\n        raise NoPortFree(\"Could not find a free port after checking 20 ports.\")\n\n    process = subprocess.Popen(\n        [\n            \"gcloud\",\n            \"workstations\",\n            \"start-tcp-tunnel\",\n            f\"--project={project}\",\n            f\"--cluster={cluster}\",\n            f\"--config={config}\",\n            f\"--region={location}\",\n            f\"--region={location}\",\n            f\"{name}\",\n            \"22\",\n            f\"--local-host-port=:{port}\",\n        ],\n        text=True,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n    )\n    if process.poll() is not None:\n        if process.returncode != 0:\n            raise CalledProcessError(process.stderr.read())\n\n    # use rsync to sync files from local to workstation\n    source_path = os.path.expanduser(source)\n    destination_path = f\"localhost:{destination}\"\n\n    command = [\n        \"rsync\",\n        \"-av\",\n        \"--exclude=.venv\",\n        \"--exclude=.git\",\n        \"--exclude=.DS_Store\",\n        \"-e\",\n        f\"ssh -p {port} -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null\",\n        source_path,\n        destination_path,\n    ]\n    counter = 0\n    while check_socket(\"localhost\", port):\n        if counter &gt;= 10:\n            break\n        time.sleep(1)\n        counter += 1\n\n    result = subprocess.run(command, capture_output=True, text=True)\n    process.kill()\n    return result\n</code></pre>"},{"location":"cli/","title":"Command Line Usage","text":"<p>This page provides usage for workstation CLI.</p>"},{"location":"cli/#workstation","title":"workstation","text":"<p>Create and manage Google Cloud Workstation.</p> <p>Usage:</p> <pre><code>workstation [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#create","title":"create","text":"<p>Create a workstation.</p> <p>Usage:</p> <pre><code>workstation create [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--config</code>, <code>-c</code> text Name of workstation config None <code>--project</code>, <code>-p</code> text GCP Project name, if not provided will use the default project in gcloud config. None <code>--location</code>, <code>-l</code> text Workstation location, if not provided will use the default location in gcloud config. <code>us-central1</code> <code>--cluster</code> text Cluster used for workstations. <code>cluster-public</code> <code>--name</code> text Name of the workstation to create. None <code>--proxy</code> text proxy setting. None <code>--no-proxy</code> text No proxy setting. None <code>--env</code>, <code>-e</code> Environment variables to set at runtime. None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#delete","title":"delete","text":"<p>Delete workstation.</p> <p>Usage:</p> <pre><code>workstation delete [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--name</code> text Name of the workstation to delete. None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#list","title":"list","text":"<p>List workstations.</p> <p>Usage:</p> <pre><code>workstation list [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--config</code>, <code>-c</code> text Name of workstation config None <code>--project</code>, <code>-p</code> text GCP Project name, if not provided will use the default project in gcloud config. None <code>--location</code>, <code>-l</code> text Workstation location, if not provided will use the default location in gcloud config. <code>us-central1</code> <code>--cluster</code> text Cluster used for workstations. <code>cluster-public</code> <code>--json</code> boolean print json output <code>False</code> <code>-u</code>, <code>--user</code> text Lists workstations only from a given user. <code>runner</code> <code>-a</code>, <code>--all</code> boolean List workstations from all users. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#list-configs","title":"list-configs","text":"<p>List workstation configurations.</p> <p>Usage:</p> <pre><code>workstation list-configs [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--config</code>, <code>-c</code> text Name of workstation config None <code>--project</code>, <code>-p</code> text GCP Project name, if not provided will use the default project in gcloud config. None <code>--location</code>, <code>-l</code> text Workstation location, if not provided will use the default location in gcloud config. <code>us-central1</code> <code>--cluster</code> text Cluster used for workstations. <code>cluster-public</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#logs","title":"logs","text":"<p>Open logs for the workstation.</p> <p>Usage:</p> <pre><code>workstation logs [OPTIONS] NAME\n</code></pre> <p>Options:</p> Name Type Description Default <code>--project</code> text Name of the workstation GCP project. None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#start","title":"start","text":"<p>Start workstation and optionally open it either locally with VSCode or through VSCode in a browser.</p> <p>Usage:</p> <pre><code>workstation start [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--name</code> text Name of the workstation to start. _required <code>--code</code> boolean Open workstation in VSCode locally. This requires setup illustrated in https://workstation.mlds.cash/#connect-to-a-workstation-with-local-vs-code <code>False</code> <code>--browser</code> boolean Open workstation with a remote VSCode session in a web browser. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#stop","title":"stop","text":"<p>Stop workstation.</p> <p>Usage:</p> <pre><code>workstation stop [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--name</code> text Name of the workstation to stop. None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli/#sync","title":"sync","text":"<p>Sync files to workstation.</p> <p>Usage:</p> <pre><code>workstation sync [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>-n</code>, <code>--name</code> text Name of the workstation to sync. None <code>--help</code> boolean Show this message and exit. <code>False</code>"}]}